#!/usr/bin/env python
#
# The MIT License (MIT)
#
# Copyright (c) 2025 Steffen Nuessle
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

import argparse
import json
import os
import sys

#
# Terminology:
#
#   An *action* describes either the compilation of a source file or the linking
#   of a library or an executable.
#
#   A *target* consists of a series of compile actions followed by a final link
#   action. The data associated with a target is largely unprocessed and is
#   primarily derived from raw command-line arguments.
#
#   A *build specification* (also known as a *build spec* or simply a *spec*)
#   is a list of build actions generated by aggregating the actions of a
#   targetâ€™s dependencies. It contains all the information required to build a
#   target, including any libraries and object files it depends on. Since a
#   specification is represented as a list of actions, multiple specifications
#   can be easily combined by concatenating them.
#
#   A *build* is the rendered Jinja2 output of a template that has been provided
#   with a build specification as input.
#


class YangData:
    class DataManager:
        def __init__(self, build_directory):
            self._build_directory = os.path.abspath(build_directory)
            self._cache = {}

        def _get_build_file(self, output):
            name = os.path.basename(output)
            name = os.path.splitext(name)[0]

            return os.path.join(self._build_directory, f'target-{name}.json')

        def load(self, output):
            if data := self._cache.get(output):
                return data

            path = self._get_build_file(output)

            if os.path.exists(path):
                with open(path, 'r') as f:
                    data = json.load(f)

                self._cache[output] = data
                return data

            return None

        def save(self, output, data):
            path = self._get_build_file(output)

            with open(path, 'w') as f:
                print(json.dumps(data, indent=4), file=f)

            self._cache[output] = data

    def __init__(self, build_dir):
        self._build_directory = os.path.abspath(build_dir)
        self._data_manager = YangData.DataManager(self._build_directory)

        self._build = []


    def _add_compile(
        self,
        compile_rule,
        source,
        defines,
        includes,
        options
    ):
        import hashlib

        hashsum = hashlib.sha1(source.encode()).hexdigest()
        output_dir = os.path.join(self._build_directory, 'objects', hashsum)

        source = os.path.abspath(source)
        name = os.path.basename(source)
        obj = os.path.join(output_dir, f'{name}.o')
        dep = os.path.join(output_dir, f'{name}.d')

        return {
            'action': 'compile',
            'rule': compile_rule,
            'input': source,
            'defines': defines,
            'includes': [os.path.abspath(x) for x in includes],
            'options': options,
            'object': obj,
            'depfile': dep,
        }

    def add_compile(
        self,
        compile_rule,
        sources = [],
        defines = [],
        includes = [],
        options = []
    ):
        # Create a compilation entry for each source file
        self._build.extend(
            self._add_compile(compile_rule, x, defines, includes, options)
            for x in sources
        )

    def _get_target_path(self, link_type, output):
        if os.path.dirname(output):
            # Use the user-specified path
            return os.path.abspath(output)

        # Use a pre-defined path
        if link_type == 'static-library':
            dir_name = 'archives'
        else:
            dir_name = 'bin'

        return os.path.join(self._build_directory, dir_name, output)

    def add_link(
        self,
        link_type,
        link_rule,
        output,
        directories = [],
        libraries = [],
        options = [],
    ):
        if self._build and self._build[-1]['action'] == 'link':
            raise RuntimeError('only one link action allowed')

        if link_type != 'object-library' and not link_rule:
            raise RuntimeError(f'link-type "{link_type}" requires a link-rule')

        if link_type == 'object-library':
            pass


        output = self._get_target_path(link_type, output)

        self._build.append({
            'action': 'link',
            'rule': link_rule,
            'link-type': link_type,
            'inputs': [x['object'] for x in self._build],
            'output': output,
            'directories': directories,
            'libraries': libraries,
            'options': options,
        })

        self._data_manager.save(output, self._build)

    def _aggregate_detail(self, build):
        # The link action is always located at the end of a build
        link = build[-1]

        aggregate = []

        # Recursively descend into the libraries to start the aggregation
        # on the leaf builds and then move up until the root is reached.
        for name in link['libraries']:
            if lib_build := self._data_manager.load(name):
                aggregate.extend(self._aggregate_detail(lib_build))

        # Aggregate data from the prerequisites up to the target
        for lib_name in link['libraries']:
            if lib_build := self._data_manager.load(lib_name):
                lib_link = lib_build[-1]

                link_type = lib_link['link-type']

                if link_type == 'static-library':
                    link['inputs'].append(lib_link['output'])
                elif link_type == 'object-library':
                    link['inputs'].extend(x['object'] for x in lib_build[:-1])
                else:
                    raise RuntimeError(f'invalid link type \'{link_type}\'')
            else:
                # Externally built library
                link['inputs'].append(lib_name)

        # Shared libraries are not supported.
        link['libraries'] = []

        aggregate.append(build)

        return aggregate


    def aggregate(self, target):
        build = self._data_manager.load(target)
        if not build:
            raise RuntimeError(f'unknown target \'{target}\'')

        builds = self._aggregate_detail(build)
        return [action for build in builds for action in build]


class Jinja2Ninja:
    def __init__(self, path):
        import jinja2

        with open(path, 'r') as f:
            data = f.read()

        env = jinja2.Environment(keep_trailing_newline=True)

        self.template = env.from_string(data)

    def render(self, **kwargs):
        import datetime

        now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        return self.template.render(date=now, **kwargs)

def main_add_target(args):
    data = YangData(args.build_directory)

    data.add_compile(
        args.compile_rule,
        args.sources,
        args.compile_definitions,
        args.include_directories,
        args.compile_options
    )

    data.add_link(
        args.link_type,
        args.link_rule,
        args.link_output,
        args.link_directories,
        args.link_libraries,
        args.link_options
    )

def main_aggregate_spec(args):
    data = YangData(args.build_directory)
    spec = data.aggregate(args.target)

    print(json.dumps(spec, indent=4), file=args.output)


def main_generate_build(args):
    data = []

    for spec in args.build_spec:
        data.extend(json.load(open(spec, 'r')))

    j2n = Jinja2Ninja(args.build_template)
    build = j2n.render(build=data)

    print(build, file=args.output)


def main():

    parser = argparse.ArgumentParser(
        prog='yang',
        description=(
            "Utility tool to generate trivial ninja files for C projects."
        ),
        epilog='',
        fromfile_prefix_chars='@',
        add_help=True,
        allow_abbrev=True,
        exit_on_error=True
    )

    subparsers = parser.add_subparsers(required=True)

    add_parser = subparsers.add_parser(
        'add',
        help='Add a target to the yang build data'
    )
    add_parser.add_argument(
        '--build-directory',
        help=(
            'The directory used for storing files and targets associated '
            'with it.',
        ),
        required=True,
        type=str
    )
    add_parser.add_argument(
        '--sources',
        help='The source files used to build the target.',
        nargs='*',
        required=False,
        default=[],
        type=str
    )
    add_parser.add_argument(
        '--include-directories',
        help='The include directories used for building the target',
        nargs='*',
        default=[],
        required=False,
        type=str
    )
    add_parser.add_argument(
        '--compile-definitions',
        help=(
            'The compile definitions (preprocessor macros) used for compiling '
            'the source files.'
        ),
        nargs='*',
        default=[],
        type=str
    )

    add_parser.add_argument(
        '--compile-options',
        help='The compile options used for compiling the source files.',
        action='append',
        default=[],
        type=str
    )

    add_parser.add_argument(
        '--compile-rule',
        help=(
            'The compile rule in the ninja template file that shall be used '
            'for compiling the specified source files.'
        ),
        required=True,
        type=str
    )

    add_parser.add_argument(
        '--link-directories',
        nargs='*',
        default=[],
        type=str
    )

    add_parser.add_argument(
        '--link-libraries',
        help=(
            'Specifies the libraries which will be used during linking to '
            'generate the linker output. Only static or object libraries '
            'are supported.'
        ),
        nargs='*',
        default=[],
        type=str
    )

    add_parser.add_argument(
        '--link-options',
        help='The options passed to the linker.',
        action='append',
        default=[],
        type=str
    )

    add_parser.add_argument(
        '--link-type',
        help='Specifies what output the linker is going to produce',
        required=True,
        choices=['executable', 'object-library', 'static-library'],
        type=str,
    )
    add_parser.add_argument(
        '--link-output',
        help=(
            'The name or path of the linker output. If a file name is '
            'specified, the linker output will be stored in a predefined '
            'directory.'
        ),
        default='a.out',
        type=str
    )

    add_parser.add_argument(
        '--link-rule',
        help=(
            'The link rule in the ninja template file that shall be used '
            'for linking the target.'
        ),
        nargs='?',
        default='',
        required=False,
        type=str
    )
    add_parser.set_defaults(func=main_add_target)


    aggregate_parser = subparsers.add_parser(
        'aggregate',
        help='Aggregate the known build data into a build specification.'
    )
    aggregate_parser.add_argument(
        '--target',
        help='',
        required=True
    )
    aggregate_parser.add_argument(
        '--output',
        help='',
        required=False,
        default=sys.stdout,
        type=lambda x: open(x, 'w')
    )
    aggregate_parser.add_argument(
        '--build-directory',
        help='',
        required=True,
        type=str
    )
    aggregate_parser.set_defaults(func=main_aggregate_spec)


    generate_parser = subparsers.add_parser('generate', help='')
    generate_parser.add_argument(
        '--build-spec',
        help='',
        nargs='+',
        required=True,
        type=str
    )
    generate_parser.add_argument(
        '--build-template',
        help=(
            'Specifies the jinja2 template build file which will be used to '
            'render the final build.ninja file. No output will be generated '
            'if no template is specified.'
        ),
        required=False,
        type=str
    )
    generate_parser.add_argument(
        '--output', '-o',
        help='',
        required=False,
        default=sys.stdout,
        type=lambda x: open(x, 'w')
    )
    generate_parser.set_defaults(func=main_generate_build)


    args = parser.parse_args()
    args.func(args)

    sys.exit(0)

if __name__ == '__main__':
    main()
